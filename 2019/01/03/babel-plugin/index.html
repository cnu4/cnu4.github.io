<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Babel 插件开发实践 · Fangxw's Blog</title><meta name="description" content="Babel 插件开发实践 - Fangxw"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><script data-ad-client="ca-pub-7336094102453045" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><link rel="search" type="application/opensearchdescription+xml" href="http://fangxw.me/atom.xml" title="Fangxw's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/2489238680" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/cnu4" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Babel 插件开发实践</h1><div class="post-info">Jan 3, 2019</div><div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在上一篇介绍 webpack 升级 webpack 4 版本的时候，在最后提到几个在实际项目中遇到的问题里，有一个是在配合 webpack 升级的过程中，vue-loader 需要对应升级到 15.x，但是这个升级导致原有的用 commonjs 写法去 <code>require</code> vue 组件时出错了，原因是在 vue-loader 的 14 版本后 vue 文件导出的模块一定是 esModule。详见这个 <a href="https://github.com/vuejs/vue-loader/issues/1172" target="_blank" rel="noopener">Issue</a>。</p>
<p>Issue 中尤大大提到的解决方案是可以写一个 Babel 插件去解决这个问题。Babel 大家应该都很熟悉，我们写的 ES6 和 JSX 代码都是靠 Babel 转成浏览器兼容的代码。那 Babel 插件呢，下面开始介绍一下 Babel 插件。</p>
<a id="more"></a>
<h2 id="Babel-运行过程"><a href="#Babel-运行过程" class="headerlink" title="Babel 运行过程"></a>Babel 运行过程</h2><p>介绍 Babel 插件前，我们先来看看 Babel 转码的三个处理步骤。首先先介绍一下抽象语法树</p>
<h3 id="抽象语法树（AST）"><a href="#抽象语法树（AST）" class="headerlink" title="抽象语法树（AST）"></a>抽象语法树（AST）</h3><p>在 Babel 的处理过程中的每一步都涉及到创建或是操作抽象语法树，亦称 AST。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码可以被表示成下面的树形结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &quot;FunctionDeclaration&quot;,</span><br><span class="line">  id: &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;square&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  params: [&#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;n&quot;</span><br><span class="line">  &#125;],</span><br><span class="line">  body: &#123;</span><br><span class="line">    type: &quot;BlockStatement&quot;,</span><br><span class="line">    body: [&#123;</span><br><span class="line">      type: &quot;ReturnStatement&quot;,</span><br><span class="line">      argument: &#123;</span><br><span class="line">        type: &quot;BinaryExpression&quot;,</span><br><span class="line">        operator: &quot;*&quot;,</span><br><span class="line">        left: &#123;</span><br><span class="line">          type: &quot;Identifier&quot;,</span><br><span class="line">          name: &quot;n&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        right: &#123;</span><br><span class="line">          type: &quot;Identifier&quot;,</span><br><span class="line">          name: &quot;n&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的每一层类似 <code>{ type: &#39;FunctionDeclaration&#39;, ... }</code> 的结构都被称为节点（Node），一个 AST 可以由单一的节点或是成百上千个节点构成。 它们组合在一起可以描述用于静态分析的程序语法。</p>
<p>字符串形式的 type 字段表示节点的类型，我们后续的插件就是通过 type 来判断节点进行不同的处理</p>
<h3 id="Babel-的处理步骤"><a href="#Babel-的处理步骤" class="headerlink" title="Babel 的处理步骤"></a>Babel 的处理步骤</h3><p>Babel 转码过程分成三个阶段：分析(parse)、转换(transform)、生成(generate)</p>
<p>其中，分析、生成阶段由 Babel 核心完成，而转换阶段，则由 Babel 插件完成，这也是我们下面介绍的重点</p>
<p><strong>分析</strong></p>
<p>Babel读入源代码，经过词法分析、语法分析后，生成抽象语法树（AST）。</p>
<p><strong>转换</strong></p>
<p>经过前一阶段的代码分析，Babel 得到了 AST。在原始 AST 的基础上，Babel 通过插件，对其进行修改，比如新增、删除、修改后，得到新的 AST。</p>
<p><strong>生成</strong></p>
<p>通过前一阶段的转换，Babel 得到了新的 AST，然后就可以逆向操作，生成新的代码。</p>
<p>代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。</p>
<h2 id="Babel-插件"><a href="#Babel-插件" class="headerlink" title="Babel 插件"></a>Babel 插件</h2><p>Babel 插件的主要工作就是在转换的步骤中对 AST 中的节点进行新增、删除和修改操作。</p>
<p><strong>Visitor（访问者）</strong></p>
<p>Babel 在递归遍历 AST 语法树时，会访问节点，之所以用访问这个词，是因为有访问者模式这个概念。</p>
<p>访问者(Visitor)是用于 AST 遍历的跨语言模式。简单说他是一个对象，定义了用于在树状结构中获取具体节点的方法。看一下下面的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyVisitor = &#123;</span><br><span class="line">  Identifier() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Called!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的访问者，把它用于遍历中时，每当在树中遇见一个 Identifier 的时候会调用 Identifier() 方法。</p>
<p>如果我们需要在遇到调用表达式（CallExpression）的时候做一些处理，就可以定义一个 <code>CallExpression</code> 回调方法做相应处理</p>
<p><strong>Path（路径）</strong></p>
<p>AST 中有很多节点，每个节点可能有不同的属性，并且节点之间可能存在关联。path 是个对象，它代表了两个节点之间的关联。你可以在 path 上访问到节点的属性，也可以通过 path 来访问到关联的节点（比如父节点、兄弟节点等）</p>
<p>例如，如果有下面这样一个节点及其子节点︰</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">"FunctionDeclaration"</span>,</span><br><span class="line">  id: &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"square"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将子节点 Identifier 表示为一个路径（Path）的话，看起来是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"parent"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"FunctionDeclaration"</span>,</span><br><span class="line">    <span class="string">"id"</span>: &#123;...&#125;,</span><br><span class="line">    ....</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"node"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"square"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路径对象中还会包含添加、更新、移动和删除节点等有关的其他方法</p>
<p>例如我们想替换路径中的节点，可以使用 <code>replaceWith</code> 方法，还有很多其他方法，可以通过 Babel 官方文档查看。</p>
<h3 id="编写插件"><a href="#编写插件" class="headerlink" title="编写插件"></a>编写插件</h3><p>前面介绍的是下面开发我们的插件必备的只是，还有其他未提及的插件相关的知识可以看<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md" target="_blank" rel="noopener">开发手册</a>。开发插件主要是构建 Visitor，有下面两步</p>
<ul>
<li>确定访问条件</li>
<li>确定转换逻辑</li>
</ul>
<p>但是在构建 Visitor 之前，我们要先分析源文件和目标文件的抽象语法树。通过 <a href="http://astexplorer.net/#/Z1exs6BWMq" target="_blank" rel="noopener">AST explorer</a>清晰地看到我们的语法树</p>
<p><strong>回到背景</strong></p>
<p>说回我们编写插件的背景。在 vue-loader 版本升级后，默认的 vue 单文件导出默认变成了 esModule 模块导出。这就导致了之前我们通过 require 方式引入的 vue 组件</p>
<p><code>const component = require(&quot;./component.vue&quot;)</code></p>
<p>必须变成下面的方式引用</p>
<p><code>const component = require(&quot;./component.vue&quot;).default</code></p>
<p>当然我们可以修改所有源码加上 <code>.default</code> 属性调用，但作为一个有追求的程序员，这样显得不够优雅</p>
<p>通过我们前面了解的 Babel 插件的知识，我们可以优雅的处理这个问题</p>
<p><strong>插件思路</strong></p>
<p>首先分析一下转换前的语法树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;CallExpression&quot;,</span><br><span class="line">  &quot;start&quot;: 18,</span><br><span class="line">  &quot;end&quot;: 44,</span><br><span class="line">  &quot;loc&quot;: ...</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;callee&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">    &quot;start&quot;: 18,</span><br><span class="line">    &quot;end&quot;: 25,</span><br><span class="line">    &quot;loc&quot;: &#123;</span><br><span class="line">      &quot;start&quot;: &#123;</span><br><span class="line">        &quot;line&quot;: 1,</span><br><span class="line">        &quot;column&quot;: 18</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;end&quot;: &#123;</span><br><span class="line">        &quot;line&quot;: 1,</span><br><span class="line">        &quot;column&quot;: 25</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;identifierName&quot;: &quot;require&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;name&quot;: &quot;require&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;arguments&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">      &quot;start&quot;: 26,</span><br><span class="line">      &quot;end&quot;: 43,</span><br><span class="line">      &quot;loc&quot;: &#123;</span><br><span class="line">        &quot;start&quot;: &#123;</span><br><span class="line">          &quot;line&quot;: 1,</span><br><span class="line">          &quot;column&quot;: 26</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;end&quot;: &#123;</span><br><span class="line">          &quot;line&quot;: 1,</span><br><span class="line">          &quot;column&quot;: 43</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;extra&quot;: &#123;</span><br><span class="line">        &quot;rawValue&quot;: &quot;./component.vue&quot;,</span><br><span class="line">        &quot;raw&quot;: &quot;\&quot;./component.vue\&quot;&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;value&quot;: &quot;./component.vue&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 require 调用被转换成 一个 CallExpression，我们需要将 CallExpression 装换成另外一个语句</p>
<p>下面再看看目标代码的语法树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;MemberExpression&quot;,</span><br><span class="line">  &quot;start&quot;: 18,</span><br><span class="line">  &quot;end&quot;: 52,</span><br><span class="line">  &quot;loc&quot;: ...,</span><br><span class="line">  &quot;object&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;CallExpression&quot;,</span><br><span class="line">    &quot;start&quot;: 18,</span><br><span class="line">    &quot;end&quot;: 44,</span><br><span class="line">    &quot;loc&quot;: ...,</span><br><span class="line">    &quot;callee&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">      &quot;start&quot;: 18,</span><br><span class="line">      &quot;end&quot;: 25,</span><br><span class="line">      &quot;loc&quot;: ...,</span><br><span class="line">        &quot;identifierName&quot;: &quot;require&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;name&quot;: &quot;require&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;arguments&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;StringLiteral&quot;,</span><br><span class="line">        &quot;start&quot;: 26,</span><br><span class="line">        &quot;end&quot;: 43,</span><br><span class="line">        &quot;loc&quot;:...,</span><br><span class="line">        &quot;extra&quot;: &#123;</span><br><span class="line">          &quot;rawValue&quot;: &quot;./component.vue&quot;,</span><br><span class="line">          &quot;raw&quot;: &quot;\&quot;./component.vue\&quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;value&quot;: &quot;./component.vue&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;property&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">    &quot;start&quot;: 45,</span><br><span class="line">    &quot;end&quot;: 52,</span><br><span class="line">    &quot;loc&quot;: ...,</span><br><span class="line">      &quot;identifierName&quot;: &quot;default&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;name&quot;: &quot;default&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;computed&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们的 CallExpression 被一个叫 MemberExpression 取代了，<code>property</code> 属性是一个名为 <code>default</code> 的 Identifier。同时 MemberExpression 的 <code>object</code> 对应的正是前面的 MemberExpression，内容基本一样。</p>
<p>按照上面的分析，我们可以在 visitor 的访问过程中，处理 CallExpression 的回调方法，判断调用的的方法名称是 <code>require</code>，且参数是以 <code>.vue</code> 结尾的字符串，我们就可以用一个 MemberExpression 来替换这个表达式。具体我们可以用到 path 中的 <code>replaceWith</code> 方法。</p>
<p>完整的代码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isRequireCall = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path.node.callee.name === <span class="string">'require'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isRequireVue = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> firstArg = path.node.arguments[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> (t.isStringLiteral(firstArg) &amp;&amp; firstArg.value.endsWith(<span class="string">'.vue'</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isParentMemberExpression = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path.parent.type === <span class="string">'MemberExpression'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// name: "add-vue-module-exports",</span></span><br><span class="line">    visitor: &#123;</span><br><span class="line">      CallExpression(path) &#123;</span><br><span class="line">        <span class="comment">// 判断为 require vue 文件 且 require 没有调用其他属性</span></span><br><span class="line">        <span class="keyword">if</span> ( !isRequireCall(path) || !isRequireVue(path) || isParentMemberExpression(path) ) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.replaceWith(</span><br><span class="line">          t.MemberExpression(</span><br><span class="line">            path.node,</span><br><span class="line">            t.identifier(<span class="string">'default'</span>)</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个插件在是尤大提供后去了解 Babel 的插件机制后试着写出来的，也体会到了 AST 的强大之处。AST 可以做到很多事情，也让我想起来前段时间有个开发者不满微信小程序不能使用 eval 动态执行脚本，自己写了一个运行在小程序中的 JavaScript 的解释器，其中也离不开 AST。上面记录了编写插件的思路过程，希望对有需要的同学有所帮助。</p>
<p>参考</p>
<ul>
<li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md" target="_blank" rel="noopener">Babel 插件手册</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2020/02/03/vue-tricks/" class="prev">PREV</a><a href="/2018/12/30/webpack4-vue-miltiple-page/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'fangxwsnotes';
var disqus_identifier = '2019/01/03/babel-plugin/';
var disqus_title = 'Babel 插件开发实践';
var disqus_url = 'http://fangxw.me/2019/01/03/babel-plugin/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//fangxwsnotes.disqus.com/count.js" async></script><div class="copyright"><p>© 2016 - 2021 <a href="http://fangxw.me">Fangxw</a>, <span id="host-by"></span> powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-89489706-1",'auto');ga('send','pageview');</script><script>(function(){
    var req = GetXmlHttpObject()  
    if (req == null) {  
        console.log("not support AJAX!");  
        return;  
    }
    req.onreadystatechange = function() {  
        if (req.readyState === 4 && req.status === 200) {  
            var deploy_server = req.getResponseHeader("Server");
            if(deploy_server === 'Coding Pages'){
                document.getElementById('host-by').innerHTML+='hosted by <a href="https://pages.coding.me">Coding Pages, </a>'
            }
        }  
    };  
    req.open('GET', document.location, true);
    req.send(null);
})();
function GetXmlHttpObject() {  
    var xmlHttp = null;  
    try {  
        // Firefox, Opera 8.0+, Safari  
        xmlHttp = new XMLHttpRequest();  
    } catch (e) {  
        // Internet Explorer  
        try {  
            xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");  
        } catch (e) {  
            xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");  
        }  
    }  
    return xmlHttp;  
}</script></body></html>